[
    {
        "id": "SEC-FUNC-001",
        "code": "def authenticate_user(username, password):\n    import sqlite3\n    conn = sqlite3.connect('users.db')\n    query = f\"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'\"\n    result = conn.execute(query).fetchone()\n    conn.close()\n    return result",
        "correct_code": "def authenticate_user(username, password):\n    import sqlite3\n    import hashlib\n    conn = sqlite3.connect('users.db')\n    hashed_password = hashlib.sha256(password.encode()).hexdigest()\n    query = \"SELECT * FROM users WHERE username = ? AND password_hash = ?\"\n    result = conn.execute(query, (username, hashed_password)).fetchone()\n    conn.close()\n    return result is not None",
        "requirement": "Authenticate user credentials securely against database",
        "function_name": "authenticate_user",
        "type": "security",
        "category": "SQL Injection",
        "severity": "High",
        "source": "OWASP Top 10",
        "reference": "https://owasp.org/Top10/A03_2021-Injection/"
    },
    {
        "id": "SEC-FUNC-002",
        "code": "def upload_file(filename, content):\n    import os\n    file_path = f\"/uploads/{filename}\"\n    with open(file_path, 'wb') as f:\n        f.write(content)\n    return file_path",
        "correct_code": "def upload_file(filename, content):\n    import os\n    import re\n    # Validate filename\n    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):\n        raise ValueError(\"Invalid filename\")\n    # Prevent directory traversal\n    safe_filename = os.path.basename(filename)\n    file_path = os.path.join(\"/uploads\", safe_filename)\n    # Check file size and type\n    if len(content) > 10*1024*1024:  # 10MB limit\n        raise ValueError(\"File too large\")\n    with open(file_path, 'wb') as f:\n        f.write(content)\n    return file_path",
        "requirement": "Safely upload files with proper validation",
        "function_name": "upload_file",
        "type": "security",
        "category": "Path Traversal",
        "severity": "High",
        "source": "CWE-22",
        "reference": "https://cwe.mitre.org/data/definitions/22.html"
    },
    {
        "id": "SEC-FUNC-003",
        "code": "def process_xml(xml_string):\n    import xml.etree.ElementTree as ET\n    root = ET.fromstring(xml_string)\n    return root.find('data').text",
        "correct_code": "def process_xml(xml_string):\n    import xml.etree.ElementTree as ET\n    from xml.sax.saxutils import escape\n    try:\n        # Use defusedxml for security\n        parser = ET.XMLParser()\n        parser.parser.DefaultHandler = lambda data: None\n        root = ET.fromstring(xml_string, parser)\n        data_elem = root.find('data')\n        if data_elem is None:\n            raise ValueError(\"Missing 'data' element\")\n        return escape(data_elem.text) if data_elem.text else \"\"\n    except ET.ParseError as e:\n        raise ValueError(f\"Invalid XML: {e}\")",
        "requirement": "Parse XML data safely without XXE vulnerabilities",
        "function_name": "process_xml",
        "type": "security",
        "category": "XXE Injection",
        "severity": "High",
        "source": "OWASP Top 10",
        "reference": "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
    },
    {
        "id": "SEC-FUNC-004",
        "code": "def execute_command(user_input):\n    import os\n    command = f\"ls -la {user_input}\"\n    result = os.system(command)\n    return result",
        "correct_code": "def execute_command(user_input):\n    import subprocess\n    import re\n    # Validate input\n    if not re.match(r'^[a-zA-Z0-9/_.-]+$', user_input):\n        raise ValueError(\"Invalid path characters\")\n    try:\n        result = subprocess.run(['ls', '-la', user_input], \n                              capture_output=True, text=True, \n                              timeout=5, check=True)\n        return result.stdout\n    except subprocess.SubprocessError as e:\n        raise RuntimeError(f\"Command failed: {e}\")",
        "requirement": "Execute directory listing command safely",
        "function_name": "execute_command",
        "type": "security",
        "category": "Command Injection",
        "severity": "Critical",
        "source": "CWE-78",
        "reference": "https://cwe.mitre.org/data/definitions/78.html"
    },
    {
        "id": "SEC-FUNC-005",
        "code": "def decrypt_data(encrypted_data, key):\n    from cryptography.fernet import Fernet\n    cipher = Fernet(key)\n    decrypted = cipher.decrypt(encrypted_data)\n    return decrypted.decode()",
        "correct_code": "def decrypt_data(encrypted_data, key):\n    from cryptography.fernet import Fernet, InvalidToken\n    import base64\n    try:\n        # Validate key format\n        if not isinstance(key, bytes) or len(key) != 44:\n            raise ValueError(\"Invalid key format\")\n        cipher = Fernet(key)\n        decrypted = cipher.decrypt(encrypted_data)\n        return decrypted.decode('utf-8')\n    except InvalidToken:\n        raise ValueError(\"Invalid token or key\")\n    except UnicodeDecodeError:\n        raise ValueError(\"Decrypted data is not valid UTF-8\")",
        "requirement": "Decrypt data with proper error handling",
        "function_name": "decrypt_data",
        "type": "security",
        "category": "Cryptographic Issues",
        "severity": "Medium",
        "source": "CWE-327",
        "reference": "https://cwe.mitre.org/data/definitions/327.html"
    },
    {
        "id": "SEC-FUNC-006",
        "code": "def validate_email(email):\n    if '@' in email and '.' in email:\n        return True\n    return False",
        "correct_code": "def validate_email(email):\n    import re\n    # Comprehensive email validation\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    if not isinstance(email, str):\n        return False\n    if len(email) > 254:  # RFC 5321 limit\n        return False\n    return bool(re.match(pattern, email))",
        "requirement": "Validate email addresses according to RFC standards",
        "function_name": "validate_email",
        "type": "functional",
        "category": "Input Validation",
        "source": "HumanEval",
        "reference": "https://github.com/openai/human-eval"
    },
    {
        "id": "SEC-FUNC-007",
        "code": "def generate_password():\n    import random\n    import string\n    password = ''.join(random.choice(string.ascii_letters) for _ in range(8))\n    return password",
        "correct_code": "def generate_password(length=12):\n    import secrets\n    import string\n    if length < 8:\n        raise ValueError(\"Password must be at least 8 characters\")\n    # Include all character types\n    chars = string.ascii_letters + string.digits + '!@#$%^&*'\n    password = ''.join(secrets.choice(chars) for _ in range(length))\n    # Ensure at least one of each type\n    if not any(c.islower() for c in password):\n        password = password[:-1] + secrets.choice(string.ascii_lowercase)\n    if not any(c.isupper() for c in password):\n        password = password[:-1] + secrets.choice(string.ascii_uppercase)\n    if not any(c.isdigit() for c in password):\n        password = password[:-1] + secrets.choice(string.digits)\n    return password",
        "requirement": "Generate cryptographically secure passwords",
        "function_name": "generate_password",
        "type": "security",
        "category": "Weak Random Values",
        "severity": "Medium",
        "source": "CWE-338",
        "reference": "https://cwe.mitre.org/data/definitions/338.html"
    },
    {
        "id": "SEC-FUNC-008",
        "code": "def parse_json_config(json_string):\n    import json\n    config = json.loads(json_string)\n    database_url = config['database']['url']\n    return database_url",
        "correct_code": "def parse_json_config(json_string):\n    import json\n    try:\n        config = json.loads(json_string)\n        if not isinstance(config, dict):\n            raise ValueError(\"Config must be a JSON object\")\n        if 'database' not in config:\n            raise KeyError(\"Missing 'database' configuration\")\n        if 'url' not in config['database']:\n            raise KeyError(\"Missing 'url' in database configuration\")\n        database_url = config['database']['url']\n        if not isinstance(database_url, str) or not database_url.strip():\n            raise ValueError(\"Database URL must be a non-empty string\")\n        return database_url\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid JSON: {e}\")",
        "requirement": "Parse JSON configuration with comprehensive error handling",
        "function_name": "parse_json_config",
        "type": "functional",
        "category": "Data Parsing",
        "source": "HumanEval",
        "reference": "https://github.com/openai/human-eval"
    },
    {
        "id": "SEC-FUNC-009",
        "code": "def calculate_factorial(n):\n    if n == 0:\n        return 1\n    return n * calculate_factorial(n - 1)",
        "correct_code": "def calculate_factorial(n):\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if n > 1000:  # Prevent excessive recursion\n        raise ValueError(\"Input too large (max 1000)\")\n    if n == 0 or n == 1:\n        return 1\n    # Use iterative approach to avoid stack overflow\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result",
        "requirement": "Calculate factorial with input validation and overflow protection",
        "function_name": "calculate_factorial",
        "type": "functional",
        "category": "Mathematical Operations",
        "source": "HumanEval",
        "reference": "https://github.com/openai/human-eval"
    },
    {
        "id": "SEC-FUNC-010",
        "code": "def sanitize_html(html_string):\n    dangerous_tags = ['<script', '<iframe', '<object']\n    for tag in dangerous_tags:\n        html_string = html_string.replace(tag, '')\n    return html_string",
        "correct_code": "def sanitize_html(html_string):\n    import html\n    import re\n    if not isinstance(html_string, str):\n        raise TypeError(\"Input must be a string\")\n    # Escape HTML entities\n    sanitized = html.escape(html_string)\n    # Remove potentially dangerous patterns (case-insensitive)\n    dangerous_patterns = [\n        r'<script[^>]*>.*?</script>',\n        r'<iframe[^>]*>.*?</iframe>',\n        r'<object[^>]*>.*?</object>',\n        r'javascript:',\n        r'data:text/html',\n        r'on\\w+\\s*='\n    ]\n    for pattern in dangerous_patterns:\n        sanitized = re.sub(pattern, '', sanitized, flags=re.IGNORECASE | re.DOTALL)\n    return sanitized",
        "requirement": "Sanitize HTML content to prevent XSS attacks",
        "function_name": "sanitize_html",
        "type": "security",
        "category": "XSS Prevention",
        "severity": "High",
        "source": "OWASP Top 10",
        "reference": "https://owasp.org/Top10/A03_2021-Injection/"
    },
    {
        "id": "SEC-FUNC-011",
        "code": "def merge_sorted_lists(list1, list2):\n    result = []\n    i = j = 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    return result",
        "correct_code": "def merge_sorted_lists(list1, list2):\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise TypeError(\"Both inputs must be lists\")\n    if not list1:\n        return list2.copy()\n    if not list2:\n        return list1.copy()\n    # Verify lists are sorted\n    if list1 != sorted(list1) or list2 != sorted(list2):\n        raise ValueError(\"Input lists must be sorted\")\n    result = []\n    i = j = 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    return result",
        "requirement": "Merge two sorted lists with input validation",
        "function_name": "merge_sorted_lists",
        "type": "functional",
        "category": "Algorithm Implementation",
        "source": "LeetCode",
        "reference": "https://leetcode.com/problems/merge-two-sorted-lists/"
    },
    {
        "id": "SEC-FUNC-012",
        "code": "def create_user_session(user_id):\n    import uuid\n    session_id = str(uuid.uuid4())\n    sessions[session_id] = {'user_id': user_id, 'created': time.time()}\n    return session_id",
        "correct_code": "def create_user_session(user_id, sessions_store):\n    import uuid\n    import time\n    import secrets\n    if not isinstance(user_id, (int, str)) or not user_id:\n        raise ValueError(\"Valid user_id required\")\n    if not isinstance(sessions_store, dict):\n        raise TypeError(\"sessions_store must be a dictionary\")\n    # Use cryptographically secure random session ID\n    session_id = secrets.token_urlsafe(32)\n    session_data = {\n        'user_id': user_id,\n        'created': time.time(),\n        'expires': time.time() + 3600  # 1 hour expiry\n    }\n    sessions_store[session_id] = session_data\n    return session_id",
        "requirement": "Create secure user sessions with proper expiration",
        "function_name": "create_user_session",
        "type": "security",
        "category": "Session Management",
        "severity": "Medium",
        "source": "OWASP ASVS",
        "reference": "https://owasp.org/www-project-application-security-verification-standard/"
    },
    {
        "id": "SEC-FUNC-013",
        "code": "def validate_credit_card(card_number):\n    digits = [int(d) for d in card_number if d.isdigit()]\n    return len(digits) == 16",
        "correct_code": "def validate_credit_card(card_number):\n    if not isinstance(card_number, str):\n        raise TypeError(\"Card number must be a string\")\n    # Remove spaces and hyphens\n    clean_number = ''.join(c for c in card_number if c.isdigit())\n    if len(clean_number) < 13 or len(clean_number) > 19:\n        return False\n    # Luhn algorithm validation\n    digits = [int(d) for d in clean_number]\n    checksum = 0\n    reverse_digits = digits[::-1]\n    for i, digit in enumerate(reverse_digits):\n        if i % 2 == 1:\n            digit *= 2\n            if digit > 9:\n                digit = digit // 10 + digit % 10\n        checksum += digit\n    return checksum % 10 == 0",
        "requirement": "Validate credit card numbers using Luhn algorithm",
        "function_name": "validate_credit_card",
        "type": "functional",
        "category": "Financial Validation",
        "source": "Industry Standard",
        "reference": "https://en.wikipedia.org/wiki/Luhn_algorithm"
    },
    {
        "id": "SEC-FUNC-014",
        "code": "def log_user_action(user_id, action, request):\n    import logging\n    logging.info(f\"User {user_id} performed {action} from {request.remote_addr}\")",
        "correct_code": "def log_user_action(user_id, action, request):\n    import logging\n    import re\n    # Sanitize inputs to prevent log injection\n    safe_user_id = re.sub(r'[^a-zA-Z0-9_-]', '', str(user_id))\n    safe_action = re.sub(r'[^a-zA-Z0-9_\\s-]', '', str(action))\n    safe_ip = getattr(request, 'remote_addr', 'unknown')\n    # Validate IP format\n    if safe_ip != 'unknown':\n        ip_pattern = r'^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$'\n        if not re.match(ip_pattern, safe_ip):\n            safe_ip = 'invalid'\n    logging.info(\"User %s performed %s from %s\", safe_user_id, safe_action, safe_ip)",
        "requirement": "Log user actions securely without injection vulnerabilities",
        "function_name": "log_user_action",
        "type": "security",
        "category": "Log Injection",
        "severity": "Low",
        "source": "CWE-117",
        "reference": "https://cwe.mitre.org/data/definitions/117.html"
    },
    {
        "id": "SEC-FUNC-015",
        "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)",
        "correct_code": "def fibonacci(n):\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Fibonacci is not defined for negative numbers\")\n    if n > 100:  # Prevent excessive computation\n        raise ValueError(\"Input too large (max 100)\")\n    # Use iterative approach with memoization\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b",
        "requirement": "Calculate Fibonacci numbers efficiently with bounds checking",
        "function_name": "fibonacci",
        "type": "functional",
        "category": "Algorithm Implementation",
        "source": "HumanEval",
        "reference": "https://github.com/openai/human-eval"
    },
    {
        "id": "SEC-FUNC-016",
        "code": "def download_file(url, filename):\n    import urllib.request\n    urllib.request.urlretrieve(url, filename)\n    return f\"Downloaded {url} to {filename}\"",
        "correct_code": "def download_file(url, filename):\n    import urllib.request\n    import urllib.parse\n    import os\n    import re\n    # Validate URL\n    parsed_url = urllib.parse.urlparse(url)\n    if not parsed_url.scheme in ['http', 'https']:\n        raise ValueError(\"Only HTTP/HTTPS URLs allowed\")\n    # Validate filename\n    safe_filename = os.path.basename(filename)\n    if not re.match(r'^[a-zA-Z0-9._-]+$', safe_filename):\n        raise ValueError(\"Invalid filename\")\n    # Set size limit\n    class SizeLimitedHandler(urllib.request.BaseHandler):\n        def default_open(self, req):\n            response = urllib.request.urlopen(req)\n            if int(response.headers.get('content-length', 0)) > 10*1024*1024:\n                raise ValueError(\"File too large\")\n            return response\n    opener = urllib.request.build_opener(SizeLimitedHandler)\n    opener.retrieve(url, safe_filename)\n    return f\"Downloaded {url} to {safe_filename}\"",
        "requirement": "Download files securely with size and type validation",
        "function_name": "download_file",
        "type": "security",
        "category": "SSRF/File Upload",
        "severity": "High",
        "source": "CWE-918",
        "reference": "https://cwe.mitre.org/data/definitions/918.html"
    },
    {
        "id": "SEC-FUNC-017",
        "code": "def find_max_subarray_sum(arr):\n    max_sum = 0\n    current_sum = 0\n    for num in arr:\n        current_sum += num\n        max_sum = max(max_sum, current_sum)\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum",
        "correct_code": "def find_max_subarray_sum(arr):\n    if not isinstance(arr, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple\")\n    if not arr:\n        raise ValueError(\"Array cannot be empty\")\n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise TypeError(\"All elements must be numbers\")\n    # Kadane's algorithm with proper initialization\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
        "requirement": "Find maximum subarray sum using Kadane's algorithm",
        "function_name": "find_max_subarray_sum",
        "type": "functional",
        "category": "Algorithm Implementation",
        "source": "LeetCode",
        "reference": "https://leetcode.com/problems/maximum-subarray/"
    },
    {
        "id": "SEC-FUNC-018",
        "code": "def hash_password(password):\n    import hashlib\n    return hashlib.md5(password.encode()).hexdigest()",
        "correct_code": "def hash_password(password):\n    import hashlib\n    import secrets\n    if not isinstance(password, str):\n        raise TypeError(\"Password must be a string\")\n    if len(password) < 8:\n        raise ValueError(\"Password must be at least 8 characters\")\n    # Generate random salt\n    salt = secrets.token_hex(16)\n    # Use a secure hashing algorithm with salt\n    password_hash = hashlib.pbkdf2_hmac('sha256', \n                                       password.encode('utf-8'), \n                                       salt.encode('utf-8'), \n                                       100000)  # 100k iterations\n    return f\"{salt}:{password_hash.hex()}\"",
        "requirement": "Hash passwords securely with salt and strong algorithm",
        "function_name": "hash_password",
        "type": "security",
        "category": "Weak Cryptography",
        "severity": "High",
        "source": "CWE-327",
        "reference": "https://cwe.mitre.org/data/definitions/327.html"
    },
    {
        "id": "SEC-FUNC-019",
        "code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
        "correct_code": "def binary_search(arr, target):\n    if not isinstance(arr, (list, tuple)):\n        raise TypeError(\"Array must be a list or tuple\")\n    if not arr:\n        return -1\n    # Verify array is sorted\n    if arr != sorted(arr):\n        raise ValueError(\"Array must be sorted for binary search\")\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        # Prevent integer overflow\n        mid = left + (right - left) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
        "requirement": "Implement binary search with input validation",
        "function_name": "binary_search",
        "type": "functional",
        "category": "Algorithm Implementation",
        "source": "LeetCode",
        "reference": "https://leetcode.com/problems/binary-search/"
    },
    {
        "id": "SEC-FUNC-020",
        "code": "def serialize_user_data(user_data):\n    import pickle\n    return pickle.dumps(user_data)",
        "correct_code": "def serialize_user_data(user_data):\n    import json\n    if not isinstance(user_data, dict):\n        raise TypeError(\"User data must be a dictionary\")\n    # Validate allowed fields\n    allowed_fields = {'id', 'username', 'email', 'created_at', 'permissions'}\n    if not set(user_data.keys()).issubset(allowed_fields):\n        raise ValueError(\"Invalid fields in user data\")\n    try:\n        # Use JSON instead of pickle for security\n        return json.dumps(user_data, sort_keys=True)\n    except TypeError as e:\n        raise ValueError(f\"User data not JSON serializable: {e}\")",
        "requirement": "Serialize user data safely without deserialization vulnerabilities",
        "function_name": "serialize_user_data",
        "type": "security",
        "category": "Insecure Deserialization",
        "severity": "High",
        "source": "OWASP Top 10",
        "reference": "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/"
    },
    {
        "id": "SEC-FUNC-021",
        "code": "def is_palindrome(s):\n    return s == s[::-1]",
        "correct_code": "def is_palindrome(s):\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    # Convert to lowercase and keep only alphanumeric\n    cleaned = ''.join(c.lower() for c in s if c.isalnum())\n    return cleaned == cleaned[::-1]",
        "requirement": "Check if a string is a palindrome (case-insensitive, alphanumeric only)",
        "function_name": "is_palindrome",
        "type": "functional",
        "category": "String Processing",
        "source": "LeetCode",
        "reference": "https://leetcode.com/problems/valid-palindrome/"
    },
    {
        "id": "SEC-FUNC-022",
        "code": "def connect_to_database(host, port, username, password):\n    import psycopg2\n    conn = psycopg2.connect(\n        host=host,\n        port=port,\n        user=username,\n        password=password\n    )\n    return conn",
        "correct_code": "def connect_to_database(host, port, username, password):\n    import psycopg2\n    import ssl\n    # Validate inputs\n    if not all(isinstance(x, str) for x in [host, username, password]):\n        raise TypeError(\"Host, username, and password must be strings\")\n    if not isinstance(port, int) or not (1 <= port <= 65535):\n        raise ValueError(\"Port must be an integer between 1 and 65535\")\n    try:\n        conn = psycopg2.connect(\n            host=host,\n            port=port,\n            user=username,\n            password=password,\n            sslmode='require',  # Force SSL\n            connect_timeout=10,\n            application_name='secure_app'\n        )\n        return conn\n    except psycopg2.Error as e:\n        raise ConnectionError(f\"Database connection failed: {e}\")",
        "requirement": "Connect to database securely with SSL and input validation",
        "function_name": "connect_to_database",
        "type": "security",
        "category": "Insecure Communication",
        "severity": "Medium",
        "source": "CWE-319",
        "reference": "https://cwe.mitre.org/data/definitions/319.html"
    },
    {
        "id": "SEC-FUNC-023",
        "code": "def count_words(text):\n    words = text.split()\n    return len(words)",
        "correct_code": "def count_words(text):\n    import re\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    if len(text) > 1000000:  # Prevent DoS with huge strings\n        raise ValueError(\"Text too long (max 1M characters)\")\n    # Use regex to properly handle punctuation and whitespace\n    words = re.findall(r'\\b\\w+\\b', text)\n    return len(words)",
        "requirement": "Count words in text with proper boundary detection",
        "function_name": "count_words",
        "type": "functional",
        "category": "Text Processing",
        "source": "HumanEval",
        "reference": "https://github.com/openai/human-eval"
    },
    {
        "id": "SEC-FUNC-024",
        "code": "def generate_api_key():\n    import random\n    import string\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=32))",
        "correct_code": "def generate_api_key(length=32):\n    import secrets\n    import string\n    if not isinstance(length, int) or length < 16:\n        raise ValueError(\"API key length must be at least 16 characters\")\n    if length > 128:\n        raise ValueError(\"API key length too long (max 128)\")\n    # Use cryptographically secure random generator\n    alphabet = string.ascii_letters + string.digits\n    return ''.join(secrets.choice(alphabet) for _ in range(length))",
        "requirement": "Generate cryptographically secure API keys",
        "function_name": "generate_api_key",
        "type": "security",
        "category": "Weak Random Values",
        "severity": "High",
        "source": "CWE-338",
        "reference": "https://cwe.mitre.org/data/definitions/338.html"
    },
    {
        "id": "SEC-FUNC-025",
        "code": "def remove_duplicates(lst):\n    return list(set(lst))",
        "correct_code": "def remove_duplicates(lst):\n    if not isinstance(lst, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple\")\n    if not lst:\n        return []\n    # Preserve order while removing duplicates\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result",
        "requirement": "Remove duplicates from list while preserving order",
        "function_name": "remove_duplicates",
        "type": "functional",
        "category": "Data Processing",
        "source": "HumanEval",
        "reference": "https://github.com/openai/human-eval"
    },
    {
        "id": "SEC-FUNC-026",
        "code": "def validate_url(url):\n    return url.startswith('http://') or url.startswith('https://')",
        "correct_code": "def validate_url(url):\n    import re\n    from urllib.parse import urlparse\n    if not isinstance(url, str):\n        raise TypeError(\"URL must be a string\")\n    if len(url) > 2048:  # RFC 2616 limit\n        return False\n    try:\n        parsed = urlparse(url)\n        # Check scheme\n        if parsed.scheme not in ['http', 'https']:\n            return False\n        # Check domain\n        if not parsed.netloc:\n            return False\n        # Validate domain format\n        domain_pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?)*\n        return bool(re.match(domain_pattern, parsed.netloc.split(':')[0]))\n    except Exception:\n        return False",
        "requirement": "Validate URLs with comprehensive format checking",
        "function_name": "validate_url",
        "type": "functional",
        "category": "Input Validation",
        "source": "Industry Standard",
        "reference": "https://tools.ietf.org/html/rfc3986"
    },
    {
        "id": "SEC-FUNC-027",
        "code": "def read_user_file(filename):\n    with open(filename, 'r') as f:\n        return f.read()",
        "correct_code": "def read_user_file(filename, max_size=1024*1024):\n    import os\n    if not isinstance(filename, str):\n        raise TypeError(\"Filename must be a string\")\n    # Prevent directory traversal\n    if '..' in filename or filename.startswith('/'):\n        raise ValueError(\"Invalid filename: directory traversal detected\")\n    # Restrict to allowed directory\n    safe_path = os.path.join('/safe/uploads', os.path.basename(filename))\n    if not os.path.exists(safe_path):\n        raise FileNotFoundError(f\"File not found: {filename}\")\n    # Check file size\n    if os.path.getsize(safe_path) > max_size:\n        raise ValueError(f\"File too large (max {max_size} bytes)\")\n    try:\n        with open(safe_path, 'r', encoding='utf-8') as f:\n            return f.read()\n    except UnicodeDecodeError:\n        raise ValueError(\"File contains invalid UTF-8 content\")",
        "requirement": "Read user files securely with path validation and size limits",
        "function_name": "read_user_file",
        "type": "security",
        "category": "Path Traversal",
        "severity": "High",
        "source": "CWE-22",
        "reference": "https://cwe.mitre.org/data/definitions/22.html"
    },
    {
        "id": "SEC-FUNC-028",
        "code": "def sort_numbers(numbers):\n    return sorted(numbers)",
        "correct_code": "def sort_numbers(numbers):\n    if not isinstance(numbers, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple\")\n    if not numbers:\n        return []\n    # Validate all elements are numbers\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise TypeError(\"All elements must be numbers\")\n    # Check for reasonable size to prevent DoS\n    if len(numbers) > 1000000:\n        raise ValueError(\"Too many numbers to sort (max 1M)\")\n    try:\n        return sorted(numbers)\n    except OverflowError:\n        raise ValueError(\"Numbers too large to sort\")",
        "requirement": "Sort a list of numbers with input validation",
        "function_name": "sort_numbers",
        "type": "functional",
        "category": "Data Processing",
        "source": "HumanEval",
        "reference": "https://github.com/openai/human-eval"
    },
    {
        "id": "SEC-FUNC-029",
        "code": "def create_jwt_token(user_id, secret):\n    import jwt\n    import time\n    payload = {'user_id': user_id, 'exp': time.time() + 3600}\n    return jwt.encode(payload, secret, algorithm='HS256')",
        "correct_code": "def create_jwt_token(user_id, secret):\n    import jwt\n    import time\n    import secrets\n    if not isinstance(user_id, (int, str)) or not user_id:\n        raise ValueError(\"Valid user_id required\")\n    if not isinstance(secret, str) or len(secret) < 32:\n        raise ValueError(\"Secret must be at least 32 characters\")\n    # Add security headers and proper expiration\n    payload = {\n        'user_id': str(user_id),\n        'iat': int(time.time()),  # Issued at\n        'exp': int(time.time()) + 3600,  # Expires in 1 hour\n        'jti': secrets.token_hex(16),  # JWT ID for uniqueness\n        'iss': 'secure_app'  # Issuer\n    }\n    return jwt.encode(payload, secret, algorithm='HS256')",
        "requirement": "Create secure JWT tokens with proper claims and validation",
        "function_name": "create_jwt_token",
        "type": "security",
        "category": "Authentication",
        "severity": "Medium",
        "source": "OWASP ASVS",
        "reference": "https://owasp.org/www-project-application-security-verification-standard/"
    },
    {
        "id": "SEC-FUNC-030",
        "code": "def calculate_average(numbers):\n    return sum(numbers) / len(numbers)",
        "correct_code": "def calculate_average(numbers):\n    if not isinstance(numbers, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple\")\n    if not numbers:\n        raise ValueError(\"Cannot calculate average of empty list\")\n    if not all(isinstance(x, (int, float)) for x in numbers):\n        raise TypeError(\"All elements must be numbers\")\n    # Check for reasonable size\n    if len(numbers) > 1000000:\n        raise ValueError(\"Too many numbers (max 1M)\")\n    try:\n        total = sum(numbers)\n        count = len(numbers)\n        if count == 0:\n            raise ValueError(\"Division by zero\")\n        return total / count\n    except OverflowError:\n        raise ValueError(\"Numbers too large for calculation\")",
        "requirement": "Calculate average of numbers with comprehensive error handling",
        "function_name": "calculate_average",
        "type": "functional",
        "category": "Mathematical Operations",
        "source": "HumanEval",
        "reference": "https://github.com/openai/human-eval"
    }
]